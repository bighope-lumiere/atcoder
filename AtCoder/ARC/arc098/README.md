## AtCoder Regular Contest 098

解説: Coming Soon...


### C - Attention

```
N人の人が東西方向に一列に並んでいます。 それぞれの人は、東または西を向いています。
誰がどの方向を向いているかは長さNの文字列Sによって与えられます。
西からi番目に並んでいる人は、Si=E なら東を、Si=W なら西を向いています。

あなたは、N人のうち誰か1人をリーダーとして任命します。
そして、リーダー以外の全員に、リーダーの方向を向くように命令します。
このとき、リーダーはどちらの方向を向いていても構いません。

並んでいる人は、向く方向を変えるのを嫌っています。
そのためあなたは、向く方向を変える人数が最小になるようにリーダーを選びたいです。
向く方向を変える人数の最小値を求めてください。
```

`S[i]` をリーダーとして、「リーダーより右の `"E"` の数 + リーダーより左の `"W"` の数」を探索しながら更新する方針だと TLE。

#### TLE解法

```python
N = int(input())
S = input()
ans = float("inf")
for i in range(N):
	ans = min(ans, S[i + 1:].count("E") + S[: i].count("W"))
print(ans)
```

そこで考え方を変える。`count()` が計算のネックになっているので、コレをなくすために、 `i` を動かしたときの増減は高々 1 であることに着目する。
すると、 `count()` を使うべきは最初の `i=0` の場合のみでよく、あとは条件に合わせて +1 or -1 しながら `i` を動かせば良い。

#### 回答案

次の提出で Python3 で 184 ms で AC.

```python
N = int(input())
S = input()
ans = [S[1:].count("E")]
for i in range(1, N):
	tmp = ans[i - 1]
	if S[i - 1] == "W":
		tmp += 1
	if S[i] == "E":
		tmp -= 1
	ans.append(tmp)
print(min(ans))
```